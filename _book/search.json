[
  {
    "objectID": "getting started.html",
    "href": "getting started.html",
    "title": "1  准备模型COMETS",
    "section": "",
    "text": "该类模型用于存储在COMETS模拟中使用的全基因组尺度代谢模型。通常情况下，我们首先会使用COBRAPy加载一个模型。然后，我们可以将这个模型传递给COMETS模型类，这使得我们可以修改COMETS特有的模型参数，比如初始种群大小\n\nimport cobra\nimport cobra.io\nimport cometspy as c\n\n# Load a textbook example model using the COBRAPy toolbox \ntest_model = cobra.io.load_model('textbook')\n\n# Use the above model to create a COMETS model\ntest_model = c.model(test_model)\n\n# Change comets specific parameters, e.g. the initial biomass of the model\n# Notre \ntest_model.initial_pop = [0, 0, 1e-7] \n\nC:\\Users\\99374\\.conda\\envs\\CarveMe\\Lib\\site-packages\\cometspy\\model.py:623: FutureWarning: The behavior of DataFrame concatenation with empty or all-NA entries is deprecated. In a future version, this will no longer exclude empty or all-NA columns when determining the result dtypes. To retain the old behavior, exclude the relevant entries before the concat operation.\n  self.smat = pd.concat([self.smat, cdf])\nC:\\Users\\99374\\.conda\\envs\\CarveMe\\Lib\\site-packages\\cometspy\\model.py:636: FutureWarning: Calling int on a single element Series is deprecated and will raise a TypeError in the future. Use int(ser.iloc[0]) instead\n  self.objective = [int(self.reactions[self.reactions.\n\n\n\n2 设置仿真参数COMETS\nCOMETS模拟的参数存储在params类中，该类仅包含一个dict对象，其中包含了参数名称及其对应的值。如果我们不带参数初始化此类，它将包含默认的参数值。一旦加载完成后，可以按照需求查看和修改这些参数值。\n\n# Create a parameters object with default values \nmy_params = c.params()\n\n# Change the value of a parameter, for example number of simulation cycles\nmy_params.set_param('maxCycles', 100)\n\n# Set some writeTotalBiomassLog parameter to True, in order to save the output\nmy_params.set_param('writeTotalBiomassLog', True)\n\n# See avaliable parameters and their values\nmy_params.show_params()\n\n\n\n\n\n\n\n\n\nVALUE\nUNITS\n\n\n\n\nBiomassLogName\nbiomass\n\n\n\nBiomassLogRate\n1\ncycles\n\n\nFluxLogName\nflux_out\n\n\n\nFluxLogRate\n5\ncycles\n\n\nMediaLogName\nmedia_out\n\n\n\n...\n...\n...\n\n\nwriteBiomassLog\nFalse\nlogical\n\n\nwriteFluxLog\nFalse\nlogical\n\n\nwriteMediaLog\nFalse\nlogical\n\n\nwriteSpecificMediaLog\nFalse\nlogical\n\n\nwriteTotalBiomassLog\nTrue\nlogical\n\n\n\n\n62 rows × 2 columns\n\n\n\n\n\n\n3 准备模拟布局COMETS\nlayout类描述了环境，即“word”的特性，包括其中存在的物种（models）。它可以为空实例化或使用COMETS模型进行实例化： 1.若不带任何参数实例化（例如：my_layout = c.layout()），则会创建一个空布局，并带有所有需要填充的必要字段。 2.如果通过传入一个模型（或多个模型）来实例化布局，则会生成一个布局，其中包含所有这些模型能够与环境交换的代谢物，其初始浓度为零，以及无限浓度（默认-1000）的金属离子。 为了查看Comets布局的不同部分，让我们首先从上述已加载的教科书模型创建一个布局：\n\nmy_layout = c.layout(test_model)\n\nC:\\Users\\99374\\.conda\\envs\\CarveMe\\Lib\\site-packages\\cometspy\\layout.py:1361: FutureWarning: The behavior of DataFrame concatenation with empty or all-NA entries is deprecated. In a future version, this will no longer exclude empty or all-NA columns when determining the result dtypes. To retain the old behavior, exclude the relevant entries before the concat operation.\n  self.media = pd.concat([self.media, new_row],\n\n\n在该环境中，layout类存储了关于物种（my_layout.models）和空间结构（my_layout.grid）的信息。在这个例子中，模型仅指教科书模型，而网格则是默认的单格结构，即只有一个单元格。\n此外，layout还以pandas数据帧的形式存储了介质信息。在这种情况下，没有预先设置任何介质成分的量。这意味着初始化时，环境中对于模型可以交换的所有代谢物及其他介质成分，其初始浓度都是零或按照默认情况设定（如金属离子为无限浓度）。\n\nmy_layout.media\n\n\n\n\n\n\n\n\n\ndiff_c\ng_refresh\ng_static\ng_static_val\ninit_amount\nmetabolite\n\n\n\n\n0\n0.000005\n0\n0\n0\n0\nac_e\n\n\n1\n0.000005\n0\n0\n0\n0\nacald_e\n\n\n2\n0.000005\n0\n0\n0\n0\nakg_e\n\n\n3\n0.000005\n0\n0\n0\n0\nco2_e\n\n\n4\n0.000005\n0\n0\n0\n0\netoh_e\n\n\n5\n0.000005\n0\n0\n0\n0\nfor_e\n\n\n6\n0.000005\n0\n0\n0\n0\nfru_e\n\n\n7\n0.000005\n0\n0\n0\n0\nfum_e\n\n\n8\n0.000005\n0\n0\n0\n0\nglc__D_e\n\n\n9\n0.000005\n0\n0\n0\n0\ngln__L_e\n\n\n10\n0.000005\n0\n0\n0\n0\nglu__L_e\n\n\n11\n0.000005\n0\n0\n0\n0\nh2o_e\n\n\n12\n0.000005\n0\n0\n0\n0\nh_e\n\n\n13\n0.000005\n0\n0\n0\n0\nlac__D_e\n\n\n14\n0.000005\n0\n0\n0\n0\nmal__L_e\n\n\n15\n0.000005\n0\n0\n0\n0\nnh4_e\n\n\n16\n0.000005\n0\n0\n0\n0\no2_e\n\n\n17\n0.000005\n0\n0\n0\n0\npi_e\n\n\n18\n0.000005\n0\n0\n0\n0\npyr_e\n\n\n19\n0.000005\n0\n0\n0\n0\nsucc_e\n\n\n\n\n\n\n\n\n当根据模型初始化时，环境中可能存在的介质化合物是至少在一个模型中有交换反应的所有化合物。上表所示的介质是一个pandas数据帧，其中存储了多种信息：\n\ninit_amount 表示在模拟网格每个单元格中添加的初始量（单位为mmol）。\ndiff_c 指示分子是否具有不同于默认扩散常数（存储在ec_layout.global_diff中）的扩散系数。\ng_static 表示该组分是否应保持静态值，即不受模拟消耗和其他效应的影响，例如，用于设定某些营养物质为无限供应。\ng_static_val 表示如果前一列（g_static）值为1，则该组分应保持的静态值是多少。\ng_refresh_val 表示在每次模拟循环后应向网格每个单元格中添加的代谢物量。\n\n此外，我们还可以设置特定于模拟网格中某个单元格的局部静态值和刷新值。\n当介质组件被设置为静态时，这意味着其浓度在每个循环后都会恢复到设定的静态值。这在我们希望某个介质组分在模拟过程中保持近乎无限供应时使用。\n当一个介质组件有刷新值时，这意味着它将在每个模拟周期通过添加设定的数量得到补充。\n局部刷新值存储在一个列表my_layout.local_refresh中，列表中的每个元素本身也是一个列表形式为 [ x y m1_r m2_r m3_r … ]，前两个元素x和y代表坐标，后面跟随的是所有代谢物按照媒体中的顺序排列的刷新值。\n局部静态值也以类似的方式存储。my_layout.local_static列表中的每个元素本身也是一个列表形式为 [ x y m1_s m1_s_v m2_s m2_s_v … ]。这里不同的是，对于每种代谢物，都有两个值，一个定义该代谢物在该坐标处是否应保持静态（m1_s, m2_s, …），另一个则表示应保持的数值（m1_s_v, m2_s_v, …）。\n请注意，local_refresh 和 local_static 可能都为空（默认情况），或者仅包含对应坐标存在至少一个非零刷新值或静态值的条目。\n最后，layout还包含了每个模型起始生物量的信息。这些信息存储在initial_pop列表中。initial_pop的每个组成部分本身就是一个格式为[x y biomass_1 biomass_2 …]的列表，用于指定每个坐标处每个模型的生物量数量。\n\n\n4 运行COMETS模拟\ncomets类利用layout对象和parameters对象来运行模拟并存储输出结果。运行一个COMETS模拟相当直接。我们首先通过传递layout对象和params对象作为参数来定义comets对象，然后调用run()方法执行模拟：\n\nmy_simulation = c.comets(my_layout, my_params)\nmy_simulation.run()\n\n\nRunning COMETS simulation ...\n\n\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xd5 in position 334: invalid continuation byte\n\n\n\n\n5 检查模拟输出及可能的错误\n该命令在后台启动COMETS Java引擎，在控制台中执行并生成标准输出（stdout）及标准错误（stderr）日志记录。这些日志可通过各自对应的字段“run_outputs”和“run_errors”进行访问查阅。\n\nprint(my_simulation.run_output)\n\nb\"-script\\r\\nrunning script file: D:\\\\HZAU\\\\bacteria\\\\building\\\\merge_model-main/.current_script_0x27819a02850\\r\\nCurrent Java version: 1.8.0_401\\r\\nParameters file .current_global_0x27819a02850 loaded.\\r\\nParameters file .current_package_0x27819a02850 loaded.\\r\\nLoading layout file '.current_layout_0x27819a02850'...\\r\\nnull\\\\COMETS_manifest.txt (\\xcf\\xb5\\xcd\\xb3\\xd5\\xd2\\xb2\\xbb\\xb5\\xbd\\xd6\\xb8\\xb6\\xa8\\xb5\\xc4\\xc2\\xb7\\xbe\\xb6\\xa1\\xa3)\\r\\nUnable to initialize manifest file. \\nContinuing without writing manifest file.\\r\\nFound 1 model files!\\r\\nLoading '.\\\\e_coli_core.cmd' ...\\r\\njava.lang.NoClassDefFoundError: gurobi/GRBException\\r\\n\\tat edu.bu.segrelab.comets.fba.FBAModel.&lt;init&gt;(FBAModel.java:224)\\r\\n\\tat edu.bu.segrelab.comets.fba.FBAModel.&lt;init&gt;(FBAModel.java:287)\\r\\n\\tat edu.bu.segrelab.comets.fba.FBAModel.loadModelFromFile(FBAModel.java:2648)\\r\\n\\tat edu.bu.segrelab.comets.fba.FBACometsLoader.loadModelFromFile(FBACometsLoader.java:2918)\\r\\n\\tat edu.bu.segrelab.comets.fba.FBACometsLoader.parseModelFileLine(FBACometsLoader.java:1168)\\r\\n\\tat edu.bu.segrelab.comets.fba.FBACometsLoader.loadLayoutFile(FBACometsLoader.java:316)\\r\\n\\tat edu.bu.segrelab.comets.Comets.loadLayoutFile(Comets.java:1657)\\r\\n\\tat edu.bu.segrelab.comets.Comets.runScript(Comets.java:541)\\r\\n\\tat edu.bu.segrelab.comets.Comets.&lt;init&gt;(Comets.java:233)\\r\\n\\tat edu.bu.segrelab.comets.Comets.main(Comets.java:2159)\\r\\n\\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\\r\\n\\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\\r\\n\\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\\r\\n\\tat java.lang.reflect.Method.invoke(Unknown Source)\\r\\n\\tat com.exe4j.runtime.LauncherEngine.launch(LauncherEngine.java:85)\\r\\n\\tat com.exe4j.runtime.WinLauncher.main(WinLauncher.java:94)\\r\\n\\tat com.install4j.runtime.launcher.WinLauncher.main(WinLauncher.java:25)\\r\\nCaused by: java.lang.ClassNotFoundException: gurobi.GRBException\\r\\n\\tat java.net.URLClassLoader.findClass(Unknown Source)\\r\\n\\tat java.lang.ClassLoader.loadClass(Unknown Source)\\r\\n\\tat sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)\\r\\n\\tat java.lang.ClassLoader.loadClass(Unknown Source)\\r\\n\\t... 17 more\\r\\n\"\n\n\n\nprint(my_simulation.run_errors)\n\nNone\n\n\n\n\n6 访问模拟结果\n成功模拟的结果存储在comets对象内的多个字段中，这取决于参数writeTotalBiomasslog、writeBiomassLog、writeFluxLog和writeMediaLog是否设置为True。\ntotal_biomass字段存储了每个时间点和物种的总生物量（汇总所有坐标上的生物量）。 biomass字段详细记录了每个时间点、坐标以及物种的具体生物量值。 media字段存储了各个时间点培养基的组成情况。 fluxes字段存储了每个物种、坐标和时间点的代谢通量数据。 此外，特定的COMETS模式会有额外的输出字段；例如，如果我们运行的是进化模拟，genotypes字段会存储每个物种的相关信息，如其祖先以及它所经历的突变等。\n所有输出文件都是pandas DataFrame格式，可以使用标准Python工具进一步分析或绘制图表。\n\nmy_simulation.total_biomass\n\nAttributeError: 'comets' object has no attribute 'total_biomass'",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>准备模型COMETS</span>"
    ]
  },
  {
    "objectID": "Growth in a test tube.html",
    "href": "Growth in a test tube.html",
    "title": "2  导入COMETS Python 工具箱",
    "section": "",
    "text": "Growth in a test tube 此简单示例展示了COMETS的基本工作流程，包括如何构建模拟布局、指定参数、加载模型以及在模拟完成后绘制数据。\nCOMETS方法的核心是动态flux平衡分析算法（Dynamic Flux Balance Analysis，由Madahevan等人于2002年提出）。对细菌代谢动力学时序进行首批成功模拟的研究之一就是Varma和Palsson（1994年）关于大肠杆菌批次培养的经典研究。此处，我们将重现该研究中的一个结果，即在仅含葡萄糖作为唯一碳源的最小培养基中进行厌氧发酵的过程。\n我们将通过设定一个充分混合的虚拟容器来模拟试管实验，其中装有1立方厘米的培养基，并接种5×10^-6克的大肠杆菌生物质。我们将底物初始组成设为11毫摩尔的葡萄糖，并提供不限量的氨和磷酸盐。对于营养物质的吸收，我们将采用经典的Michaelis-Menten动力学，使用实验测定的大肠杆菌厌氧吸收葡萄糖的Monod参数。\n在这个简单的示例中，我们使用了大肠杆菌的基础“核心”模型（Orth等人，2009年），该模型可以从http://bigg.ucsd.edu/models/e_coli_core网站下载，或者像这里所做的那样，利用CobraPy内置函数直接加载。这个模型代表了简化到基本功能（如糖酵解、三羧酸循环、戊糖磷酸途径等）的大肠杆菌代谢网络。\n该操作同时会载入所有必需的依赖库，比如 CobraPy 或 pandas。\n\nimport cometspy as c\nimport cobra.io\nimport matplotlib.pyplot as plt\n\n\n3 为模拟创建一个“布局”\n通过无参数实例化layout类，我们将创建默认的模拟布局，它表示一个体积为1立方厘米且充分混合的空间（称为“细胞”）。然后我们可以根据需要修改这个布局，在本例中，我们会添加期望浓度下的培养基成分。\n\n# Create empty 1x1 layout\ntest_tube = c.layout()\n\n# Add 11mM glucose and remove o2\ntest_tube.set_specific_metabolite('glc__D_e', 0.011)\ntest_tube.set_specific_metabolite('o2_e', 0)\n\n# Add the rest of nutrients unlimited (ammonia, phosphate, water and protons)\ntest_tube.set_specific_metabolite('nh4_e',1000);\ntest_tube.set_specific_metabolite('pi_e',1000);\ntest_tube.set_specific_metabolite('h2o_e',1000);\ntest_tube.set_specific_metabolite('h_e',1000);\n\n\n\n4 装载模型\n下一步，我们需要加载模型并将它添加到布局中（或者说，“将模型接种到我们的试管环境中”）。\n我们将通过已加载的CobraPy模型作为输入来实例化COMETS模型类。\n需要注意的是，我们将去除对葡萄糖进口速率的限制，这一限制将在模拟过程中由COMETS根据外部葡萄糖浓度的动态变化来动态设置。同时，我们将模型的初始生物质量设置为10^-6克。\n\n# create the model using CobraPy functionality\ne_coli_cobra = cobra.io.load_model('textbook')\n\n# use the loaded model to build a comets model\ne_coli = c.model(e_coli_cobra)\n\n# remove the bounds from glucose import (will be set dynamically by COMETS)\ne_coli.change_bounds('EX_glc__D_e', -1000, 1000)\n\n# set the model's initial biomass\ne_coli.initial_pop = [0, 0, 5e-6]\n\n# add it to the test_tube\ntest_tube.add_model(e_coli)\n\n\n\n5 设置模拟参数\n接下来，我们实例化params类，该类为COMETS模拟生成一套参数集，其中包含了所有参数的[待补充链接至默认值]默认值。所有参数都保存在all_params字段中，这是一个Python字典对象，因此可以方便地更改所需参数的值。\n\n# Set the parameters that are different from the default\nsim_params = c.params()\n\n\n\n6 运行模拟\n配置完毕后，我们现在可以通过传递包含模型的layout（布局）以及我们刚才创建的params对象来实例化comets类，从而运行模拟。\n\nexperiment = c.comets(test_tube, sim_params)\n\n最后，我们可以这样运行模拟：\n\nexperiment.run()\n\n\n\n7 结果分析\n我们模拟得到的结果储存在刚刚模拟完成的comets对象内部的几个pandas数据框中。通过绘制total_biomass字段，可以看到模拟模型的生长情况。\n\nax = experiment.total_biomass.plot(x = 'cycle')\nax.set_ylabel(\"Biomass (gr.)\")\n\n同样地，我们可以绘制培养基的组成情况。在这个案例中，我们将限制绘图范围仅针对那些在模拟过程中不是以不限量方式添加到体系中的组分（即“静态”化合物，比如在此模拟中氨、磷酸盐、水等）。具体实现时，我们通过限定浓度小于900毫摩尔的化合物来进行这一部分的绘图展示。\n\nmedia = experiment.media.copy()\nmedia = media[media.conc_mmol&lt;900]\n\nfig, ax = plt.subplots()\nmedia.groupby('metabolite').plot(x='cycle', ax =ax, y='conc_mmol')\nax.legend(('acetate','ethanol', 'formate', 'glucose'))\nax.set_ylabel(\"Concentration (mmol)\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>导入COMETS Python 工具箱</span>"
    ]
  },
  {
    "objectID": "Competition assay.html",
    "href": "Competition assay.html",
    "title": "3  竞争实验在实验室中常被用来检测",
    "section": "",
    "text": "例如某种突变体相对于野生型菌株的适应度。在这里，我们模拟了一个这样的实验，涉及到大肠杆菌及其一种非必需但有害的突变——从糖酵解途径中删除己糖磷酸异构酶反应。在这种竞争排除实验中，通过连续传代的方式观察突变株与野生型菌株的竞争表现。\n\n4 加载模型并创建突变体\n首先，我们加载“核心”大肠杆菌模型，并通过将己糖磷酸异构酶反应的上下界均设置为零来创建突变体。接着，我们将原始模型和突变体模型都添加到我们的试管环境布局中。\n\n# Start by loading required packages, including the COMETS toolbox\nimport cometspy as c\nimport cobra.io\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# load the models and perform the mutation\nwt = c.model(cobra.io.load_model(\"ecoli\"))\nwt.id = 'wt'\nmut = c.model(cobra.io.load_model(\"ecoli\"))\nmut.change_bounds('TPI', 0,0)\nmut.id = 'TPI_KO'\n\n# set its initial biomass, 5e-6 gr at coordinate [0,0]\nwt.initial_pop = [0, 0, 5e-8]\nmut.initial_pop = [0, 0, 5e-8]\n\n\n\n5 创建布局、添加模型和设置媒体合成\n我们创建一个空布局（“test_tube”）并设置初始营养供应。\n\n# create an empty layout\ntest_tube = c.layout()\n\n# add the models to the test tube\ntest_tube.add_model(wt)\ntest_tube.add_model(mut)\n\n设置培养基组成，向其中添加葡萄糖以及该模型所需的无机营养物质（如氨、磷酸盐）和氧气。在模拟中，这些无机营养物质被视为“静态”的，它们的值设为1000，并且永远不会耗尽。在COMETS模拟中，将代谢物视为“静态”是一种模拟无限供应代谢物的方法。\n\n# Add glucose to the media \ntest_tube.set_specific_metabolite('glc__D_e', 0.01)\n\n# Add typical trace metabolites and oxygen coli as static\ntrace_metabolites = ['ca2_e', 'cl_e', 'cobalt2_e', 'cu2_e', 'fe2_e', 'fe3_e', 'h_e', 'k_e', 'h2o_e', 'mg2_e',\n                     'mn2_e', 'mobd_e', 'na1_e', 'ni2_e', 'nh4_e', 'o2_e', 'pi_e', 'so4_e', 'zn2_e']\n\nfor i in trace_metabolites:\n    test_tube.set_specific_metabolite(i, 1000)\n    test_tube.set_specific_static(i, 1000)\n\n\n\n6 设置仿真参数\n接下来，我们创建一个参数对象并修改所需的参数 - 在本例中，仅修改模拟运行的周期数。\n\ncomp_params = c.params()\ncomp_params.set_param('maxCycles', 240)\n\n\n\n7 运行模拟\n最后，我们使用上面创建的布局和参数创建comets对象，并运行竞争分析。\n\ncomp_assay = c.comets(test_tube, comp_params)\ncomp_assay.run()\n\n我们现在绘制了这两种基因型在共培养中的生物量。\n\nbiomass = comp_assay.total_biomass\nbiomass['t'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep']\n\nmyplot = biomass.drop(columns=['cycle']).plot(x = 't')\nmyplot.set_ylabel(\"Biomass (gr.)\")\n\n我们可以对结果进行定量分析。例如，我们可以计算突变体相对于野生型的竞争适应度，即突变体的生物量增加除以野生型的生物量增加的比率：\n\ncfit = (biomass.loc[biomass['t'] == 24, 'TPI_KO'].iloc[0]/biomass.loc[biomass['t'] == 0, 'TPI_KO'].iloc[0])/(biomass.loc[biomass['t'] == 24, 'wt'].iloc[0]/biomass.loc[biomass['t'] == 0, 'wt'].iloc[0])\ncfit\n\n\n\n8 模拟串行传输\n利用COMETS工具，我们还可以模拟这两种突变体之间的连续转移竞争。我们只需调整参数，增加总的模拟时间，并在每24小时设置一次1%的小批量转移，但我们将沿用之前的test_tube环境布局。\n\nserial_params = c.params()\nserial_params.set_param('maxCycles', 240*25) # simulate 4 serial transfers of 24h each\nserial_params.set_param('batchDilution', True)\nserial_params.set_param('dilFactor', 0.01)\nserial_params.set_param('dilTime', 24)\n\n我们运行模拟\n\nserial_expt = c.comets(test_tube, serial_params)\nserial_expt.JAVA_CLASSPATH = comp_assay.JAVA_CLASSPATH\nserial_expt.run()\n\n现在绘制实验期间两个物种的生物量\n\nbiomass = serial_expt.total_biomass\nbiomass['transfer'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep']/24\n\nmyplot = biomass.drop(columns=['cycle']).plot(x = 'transfer')\nmyplot.set_ylabel(\"Biomass (gr.)\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>竞争实验在实验室中常被用来检测</span>"
    ]
  },
  {
    "objectID": "Citrate use in the LTEE.html",
    "href": "Citrate use in the LTEE.html",
    "title": "4  研究长期进化实验中柠檬酸盐的进化利用",
    "section": "",
    "text": "在此，我们演示如何使用COMETS研究特定突变对实验进化过程中种群动态的影响。为此，我们将借鉴一项最著名的进化实验——大肠杆菌长期进化实验[E. coli Long Term Evolution Experiment]。\n经过大约33000代之后，在大肠杆菌长期进化实验的一个复制群体（Ara-3）中观察到了大规模种群扩张现象（Blount等人，2008年）。这种种群扩张与两个关键突变有关，这两个突变共同促进了对空气中的柠檬酸强烈利用表型（Cit++表型）的进化。第一个突变（约在31000代时发生）导致了citT转运蛋白在有氧条件下的表达，产生了较弱的柠檬酸生长表型（Cit+，Blount等人，2012年）。随后的突变（约在33000代左右发生）引起了dctA蛋白的高度持续表达，这是一种质子驱动的二羧酸转运蛋白（Quandt等人，2014年）。由于这两个突变引入了已知的反应进入大肠杆菌代谢网络中，因此我们可以通过COMETS对其进行模拟。\n此示例模拟采用了与(Bajic等人，2018年)中相同的大肠杆菌模型、参数和反应敲除策略。\n首先，创建布局并模拟DM25培养基。\n\nimport cometspy as c\nimport matplotlib as plt\nimport cobra.io\nimport cobra\nimport pandas as pd\nimport numpy as np\n\nlayout = c.layout()\n\n#Set up media to be DM25\nlayout.add_typical_trace_metabolites()\nlayout.set_specific_metabolite('glc__D_e', 0.000139)\nlayout.set_specific_metabolite('cit_e', 0.0017)\n\n现在加载模型并构建突变体。为了展示与COBRApy工具箱的兼容性，我们将通过COBRA加载模型并对模型进行突变操作，然后将这些修改后的模型作为输入构建COMETS模型。\n不同于LTEE（长期进化实验）的祖先菌株REL606（以及一般的大肠杆菌），虽然它们具有利用柠檬酸所必需的基因但在有氧条件下并不表达这些基因，而iJO1366模型默认情况下对柠檬酸和琥珀酸的利用反应是未加限制的。因此，要复现祖先表型，可以通过敲除三个反应：CITt7pp（编码citT的转运反应）、SUCCt2_2pp（编码dctA的转运反应）和SUCCt2_3pp（编码dcuA或dcuB的转运反应）。\n\n# Load the E. coli iJO1366 model \nmod  = cobra.io.load_model('ecoli')\n\n# Set exchange reaction lower bounds to -1000 to allow them being controlled by COMETS \nfor i in mod.reactions:\n    if 'EX_' in i.id:\n        i.lower_bound =-1000.0\n\n#now create the mutants \nmod.reactions.SUCCt2_3pp.upper_bound=0.0\nCitTdctA = mod.copy()\nmod.reactions.SUCCt2_2pp.upper_bound =0.0\nCitT = mod.copy()\nmod.reactions.CITt7pp.upper_bound =0.0\nWT = mod.copy()\nWT.id= 'Ancestor'\nCitT.id = 'Cit+'\nCitTdctA.id = 'Cit++'\n\n# Generate comets models and set their initial population size\np = c.model(WT)\np.initial_pop = [0, 0, 3.9e-11] # We'll introduce genotypes 100 cells at a time to avoid the risk of them going extinct through drift\np2 = c.model(CitT)\np2.initial_pop = [0, 0, 0] # not present at start\np3 = c.model(CitTdctA)\np3.initial_pop = [0, 0, 0] # not present at start\n\n# Add the models to the simulation \nlayout.add_model(p)\nlayout.add_model(p2)\nlayout.add_model(p3)\n\n设置模拟的参数。我们使用 1 小时作为 COMETS 时间步长来加速模拟。将其缩短到更常用的 0.1 小时不会对最终结果产生重大影响，但确实会显着增加运行此模拟所需的时间。\n\n### Setting paramaters for the simulation ###\nb_params = c.params()\nb_params.all_params['timeStep'] = 1.0 \nb_params.all_params['deathRate'] = 0.01\nb_params.all_params['batchDilution'] =True\nb_params.all_params['dilTime'] =24\nb_params.all_params['dilFactor'] =100\nb_params.all_params['cellSize']= 3.9e-13 #Size of a single cell\nb_params.all_params['minSpaceBiomass'] = 3.8e-13\n\n执行模拟。我们将整个模拟过程分为三个独立的COMETS运行阶段。从第25000代开始模拟，并运行大约6000代。在大约第31000代时，我们引入CitT基因型，并继续运行约2000代。最后，在大约第33000代时，我们引入CitTdctA基因型，并进行最后6000代的模拟。每次运行时，我们都将以前一次运行结束时的生物量组成作为新的起始条件。每一轮模拟中获得的生物量数据都会被分别存储在一个单独的数据框中，然后我们将这些数据框连接起来以便进行后续的综合分析。\n\ncycles_per_day = 24.0/b_params.all_params['timeStep']\n\n# We'll start at Generation 25,000.  and run for around 6000 generations\nbatch_test = c.comets(layout, b_params)\nbatch_test.parameters.all_params['maxCycles'] = int(900*cycles_per_day)\nbatch_test.run()\nphase_1 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13),\n                        'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13),\n                        'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13),\n                        'Generations' : 6.67*(batch_test.total_biomass.cycle+1)/cycles_per_day + 25000})\n\n# At roughly Generation 31,000 we introduce the CitT genotype and run for around 2000 Generations\nbatch_test.layout.models[0].initial_pop = [0, 0, float(batch_test.total_biomass.Ancestor.tail(1))]\nbatch_test.layout.models[1].initial_pop = [0, 0, 3.9e-11]\nbatch_test.layout.build_initial_pop()\nbatch_test.parameters.set_param('maxCycles', int(300*cycles_per_day))\nbatch_test.run()\nphase_2 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13),\n                        'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13),\n                        'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13),\n                        'Generations' : 6.67*(batch_test.total_biomass.cycle)/cycles_per_day + max(phase_1.Generations)})\n\n# At roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generationr \nbatch_test.layout.models[0].initial_pop = [0, 0, float(batch_test.total_biomass.Ancestor.tail(1))]\nbatch_test.layout.models[1].initial_pop = [0, 0, float(batch_test.total_biomass['Cit+'].tail(1))]\nbatch_test.layout.models[2].initial_pop = [0, 0, 3.9e-11]\nbatch_test.layout.build_initial_pop()\nbatch_test.parameters.set_param('maxCycles', int(900*cycles_per_day))\nbatch_test.run()\nphase_3 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13),\n                        'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13),\n                        'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13),\n                        'Generations' : 6.67*(batch_test.total_biomass.cycle)/cycles_per_day + max(phase_2.Generations) })\n\n将三次运行的所有结果组合在一起，并绘制随时间变化的固定相种群大小。\n\n#Remove the final timepoint from each phase\nphase_1.drop(phase_1.tail(1).index, inplace=True)\nphase_2.drop(phase_2.tail(1).index, inplace=True)\nphase_3.drop(phase_3.tail(1).index, inplace=True)\n\nfinal_df = pd.concat([phase_1,phase_2,phase_3])\nfinal_df.reindex()\nfinal_df = final_df[np.round((final_df.Generations - 25000) % 6.67,3) == 6.67]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>研究长期进化实验中柠檬酸盐的进化利用</span>"
    ]
  },
  {
    "objectID": "Circular colony growth.html",
    "href": "Circular colony growth.html",
    "title": "5  模拟细菌菌落在平面上的生长和繁殖：圆形菌落",
    "section": "",
    "text": "该协议复现了主要文本中的模拟程序，该程序通过生长细胞间的机械推动来模拟菌落扩张现象。所实现模型的一个特点是，其菌落形态会随着密集堆积参数的不同值发生转变。在这个协议中，我们将选择一组参数，使得模拟得到的是圆形菌落形态。而在“分支菌落”场景中，我们将选取能够导致菌落呈现分支状生长的参数。\n此外，我们还将展示如何从单一种营养物的摄取构建一个简单的代谢模型，并只包含一个与生物量增长相关的反应。\n值得注意的是，尽管在论文中使用的布局较大，但在本操作中我们会将其设计得小很多，这样可以大大加快运行速度。\n\nimport cobra\nimport cobra.io # for the ijo1366 model\nimport sys\nimport numpy as np\nimport cometspy as c\n\n首先，让我们使用cobrapy的功能制作一个“toy”模型。它直接将细胞外碳转化为生物质。\n\ncarbon = cobra.Metabolite(\"carbon\",\n                           compartment = \"e\")\ncarbon_exch = cobra.Reaction(\"Carbon_exch\",\n                            lower_bound = -1.,\n                            upper_bound = 1000.)\ncarbon_exch.add_metabolites({carbon: -1.})\nBiomass = cobra.Reaction(\"Biomass\",\n                        lower_bound = 0.,\n                        upper_bound = 1000.)\nBiomass.add_metabolites({carbon: -1.})\ntoy = cobra.Model(\"toy\")\ntoy.add_reactions([carbon_exch, Biomass])\n#toy.add_reactions([carbon_exch, carbon_transport, Biomass])\ntoy.objective = \"Biomass\"\ntoy.repair()\n\n我们可以通过在 cobrapy 中执行 FBA 来测试模型是否运行。它产生的生物量应该与carbon_exch的下限一样多。\n\nprint(toy.medium)\nprint(toy.optimize().objective_value)\n\n{'Carbon_exch': 1.0}\n1.0\n\n\n现在，我们将将其转换为COMETS模型，设置其初始生物量，并设置第一组对流参数。这些是用这个玩具模型获得圆形菌落所需的参数。请注意，对于这种形式的生物质传播，时间步长必须设置得非常低。\n\ngrid_size = 50\n\ntoy_comets = c.model(toy)\ntoy_comets.initial_pop = [int(grid_size / 2),int(grid_size / 2),1.0]\ntoy_comets.reactions.loc[toy_comets.reactions.EXCH, \"LB\"] = -1000\ntoy_comets.add_convection_parameters(packedDensity = 0.5,\n                                    elasticModulus = 1.e-4,\n                                    frictionConstant = 1.0,\n                                    convDiffConstant = 0.0)\ntoy_comets.add_noise_variance_parameter(20.)\n\nC:\\Users\\99374\\.conda\\envs\\CarveMe\\Lib\\site-packages\\cometspy\\model.py:623: FutureWarning: The behavior of DataFrame concatenation with empty or all-NA entries is deprecated. In a future version, this will no longer exclude empty or all-NA columns when determining the result dtypes. To retain the old behavior, exclude the relevant entries before the concat operation.\n  self.smat = pd.concat([self.smat, cdf])\nC:\\Users\\99374\\.conda\\envs\\CarveMe\\Lib\\site-packages\\cometspy\\model.py:636: FutureWarning: Calling int on a single element Series is deprecated and will raise a TypeError in the future. Use int(ser.iloc[0]) instead\n  self.objective = [int(self.reactions[self.reactions.\n\n\n我们确保COMETS模型不将生物质反应视为交换。\n\ntoy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH\"] = False\ntoy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH_IND\"] = 0\ntoy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\", \"LB\"] = 0\n\n本次模拟的布局将在一个100x100网格上设立单一、居中的菌落。碳源将会在整个区域内均匀分布。\n\nly = c.layout([toy_comets])\nly.grid = [grid_size, grid_size]\nly.set_specific_metabolite(\"carbon\", 1.)\n\nC:\\Users\\99374\\.conda\\envs\\CarveMe\\Lib\\site-packages\\cometspy\\layout.py:1361: FutureWarning: The behavior of DataFrame concatenation with empty or all-NA entries is deprecated. In a future version, this will no longer exclude empty or all-NA columns when determining the result dtypes. To retain the old behavior, exclude the relevant entries before the concat operation.\n  self.media = pd.concat([self.media, new_row],\n\n\n我们需要设置的主要参数是“biomassmotionstyle”，必须将其设置为“Convection 2D”。为了捕捉空间信息，除了记录总生物量外，我们还会记录个体生物量的变化。最后，我们还会调整一些其他参数。这些参数都被存储在一个名为all_params的字典中。\n\np = c.params()\n\np.set_param(\"biomassMotionStyle\", \"Convection 2D\")\np.set_param(\"writeBiomassLog\", True)\np.set_param(\"BiomassLogRate\", 100)\np.set_param(\"maxCycles\", 2000)\np.set_param(\"timeStep\", 0.0005)\np.set_param(\"spaceWidth\", 1)\np.set_param(\"maxSpaceBiomass\", 10)\np.set_param(\"minSpaceBiomass\", 0.25e-10)\np.set_param(\"allowCellOverlap\", True)\np.set_param(\"growthDiffRate\", 0)\np.set_param(\"flowDiffRate\", 3e-9)\np.set_param(\"exchangestyle\", \"Monod Style\")\np.set_param(\"defaultKm\", 0.01)\np.set_param(\"defaultHill\", 1)\np.set_param(\"defaultVmax\", 100)\n\n现在我们制作一个模拟对象并运行它。这可能需要一段时间.\n\nsim = c.comets(ly, p)\nsim.run() # set delete_files = False to maintain all comets-generated files\n\n\nRunning COMETS simulation ...\n\n\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xd5 in position 316: invalid continuation byte\n\n\n现在让我们绘制结果图。我们使用辅助脚本“get_biomass_image”，它需要模型的名称和时间步长。然后我们使用 matplotlib 来显示它。\n\nim = sim.get_biomass_image('toy', 2000)\nfrom matplotlib import pyplot as plt\nimport matplotlib.colors, matplotlib.cm\nmy_cmap = matplotlib.cm.get_cmap(\"copper\")\nmy_cmap.set_bad((0,0,0))\nplt.imshow(im, norm = matplotlib.colors.LogNorm(), cmap = my_cmap)  \n\nAttributeError: 'comets' object has no attribute 'biomass'\n\n\n我们可以在一个简单的循环中平铺时间序列。\n\nbig_image = np.zeros((grid_size * 4, grid_size * 5))\nim_cycles = np.arange(p.all_params[\"BiomassLogRate\"], p.all_params[\"maxCycles\"] + p.all_params[\"BiomassLogRate\"],\n                      p.all_params[\"BiomassLogRate\"])\nfor i, cycle in enumerate(im_cycles):\n    big_image[(grid_size * int(i / 5)):(grid_size + grid_size * int(i / 5)),(grid_size * (i % 5)):(grid_size + grid_size * (i % 5))] = sim.get_biomass_image(\"toy\", cycle)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>模拟细菌菌落在平面上的生长和繁殖：圆形菌落</span>"
    ]
  },
  {
    "objectID": "Branching colony growth.html",
    "href": "Branching colony growth.html",
    "title": "6  在平坦表面上模拟细菌菌落的生长与传播：分支菌落",
    "section": "",
    "text": "该协议与模拟圆形菌落的协议完全相同，只是在COMETS模型中改动了几处参数，使得菌落呈现出分支生长的特征。\n\nimport cobra\nimport cobra.io # for the ijo1366 model\nimport sys\nimport numpy as np\n#sys.path.append(\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/cometspy\")\nimport cometspy as c\n\n首先，让我们使用cobrapy的功能制作一个“toy”模型。它直接将细胞外碳转化为生物质。\n\ncarbon = cobra.Metabolite(\"carbon\",\n                           compartment = \"e\")\ncarbon_exch = cobra.Reaction(\"Carbon_exch\",\n                            lower_bound = -1.,\n                            upper_bound = 1000.)\ncarbon_exch.add_metabolites({carbon: -1.})\nBiomass = cobra.Reaction(\"Biomass\",\n                        lower_bound = 0.,\n                        upper_bound = 1000.)\nBiomass.add_metabolites({carbon: -1.})\ntoy = cobra.Model(\"toy\")\ntoy.add_reactions([carbon_exch, Biomass])\ntoy.objective = \"Biomass\"\ntoy.repair()\n\n我们可以通过在cobrapy中进行FBA（ Flux Balance Analysis）测试来验证模型能否运行。理论上，模型应能生成不低于碳交换通量下限的生物量（carbon_exch）。\n\nprint(toy.medium)\nprint(toy.optimize().objective_value)\n\n我们现在将此模型转化为COMETS模型，并设置其初始生物量，以及第一组对流参数。这些参数是为了使用该简化模型获得分支状菌落所必需的。请注意，对于这种形式的生物量扩散，需要将时间步长设置得非常小。\n\ngrid_size = 30\n\ntoy_comets = c.model(toy)\ntoy_comets.initial_pop = [int(grid_size / 2),int(grid_size / 2),1.0]\ntoy_comets.open_exchanges()\ntoy_comets.add_convection_parameters(packedDensity = 1.2,\n                                    elasticModulus = 5.e-3,\n                                    frictionConstant = 1.0,\n                                    convDiffConstant = 0.0)\ntoy_comets.add_noise_variance_parameter(20.)\n\n我们要确保COMETS模型不将生物量反应视为交换反应。\n\ntoy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH\"] = False\ntoy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH_IND\"] = 0\ntoy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\", \"LB\"] = 0\n\n此次模拟的布局是在100x100网格上构建一个居中单一群落。碳源会在该区域内均匀分布。\n\nly = c.layout([toy_comets])\nly.grid = [grid_size, grid_size]\nly.set_specific_metabolite(\"carbon\", 1.)\n\n我们需要设置的关键参数是“biomassmotionstyle”，必须将其设置为“Convection 2D”。接下来，为了捕获空间信息，我们将记录生物量的具体分布（而不只是记录总体生物量）。最后，我们还会调整一些其他的参数。这些参数都存储在名为all_params的字典中。\n\np = c.params()\n\np.all_params[\"biomassMotionStyle\"] = \"Convection 2D\"\np.all_params[\"writeBiomassLog\"] = True\np.all_params[\"BiomassLogRate\"] = 500\np.all_params[\"maxCycles\"] = 20000\np.all_params[\"timeStep\"] = 0.00025\np.all_params[\"spaceWidth\"] = 1\np.all_params[\"maxSpaceBiomass\"] = 10\np.all_params[\"minSpaceBiomass\"] = 0.25e-10\np.all_params[\"allowCellOverlap\"] = True\np.all_params[\"growthDiffRate\"] = 0\np.all_params[\"flowDiffRate\"] = 3e-9\np.all_params[\"exchangestyle\"] = \"Monod Style\"\np.all_params[\"defaultKm\"] = 0.01\np.all_params[\"defaultHill\"] = 1\np.all_params[\"defaultVmax\"] = 100\n\n现在我们制作一个模拟对象并运行它。这可能需要一段时间。\n\nsim = c.comets(ly, p)\n# this should all be removable once the installer is made with dependencies in a predictable location\nsim.set_classpath(\"concurrent\", \"/opt/colt/lib/concurrent.jar\")\nsim.set_classpath(\"colt\", \"/opt/colt/lib/colt.jar\")\nsim.set_classpath(\"lang3\", \"/opt/commons-lang3-3.9/commons-lang3-3.9.jar\")\nsim.set_classpath(\"jmatio\",\"/opt/jmatio/lib/jmatio.jar\")\nsim.set_classpath(\"math3\",\"/opt/commons-math3-3.6.1/commons-math3-3.6.1.jar\")\nsim.set_classpath(\"bin\",\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/jars/comets_2.10.0.jar\")\nsim.set_classpath(\"gurobi\",\"/opt/gurobi900/linux64/lib/gurobi.jar\")\nsim.set_classpath(\"jdistlib\", \"/opt/jdistlib-0.4.5-bin.jar\")\n\nsim.run(False) # use the argument delete_files = False to keep all COMETS-generated files\n\n现在让我们绘制出结果。注意我们在指定轴标签时的操作，如果不明确指定，则会默认认为“cycle”、“x”和“y”是状态变量。\n我们观察到两种物种都能存活下来，这是因为LCTStex_KO突变体通过交叉喂养从galE_KO突变体那里获取半乳糖，而galE_KO突变体则利用乳糖中的葡萄糖部分。当达到平衡时，代谢产物正如在恒化器中的典型情况一样，浓度非常低。\n\nim = sim.get_biomass_image('toy', 1500)\nfrom matplotlib import pyplot as plt\nimport matplotlib.colors, matplotlib.cm\nmy_cmap = matplotlib.cm.get_cmap(\"copper\")\nmy_cmap.set_bad((0,0,0))\nplt.imshow(im, norm = matplotlib.colors.LogNorm(), cmap = my_cmap)\n\n\nbig_image = np.zeros((grid_size * 8, grid_size * 5))\nim_cycles = np.arange(p.all_params[\"BiomassLogRate\"], p.all_params[\"maxCycles\"] + p.all_params[\"BiomassLogRate\"],\n                      p.all_params[\"BiomassLogRate\"])\nfor i, cycle in enumerate(im_cycles):\n    big_image[(grid_size * int(i / 5)):(grid_size + grid_size * int(i / 5)),(grid_size * (i % 5)):(grid_size + grid_size * (i % 5))] = sim.get_biomass_image(\"toy\", cycle)\n    plt.imshow(big_image, norm = matplotlib.colors.LogNorm(), cmap = my_cmap)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>在平坦表面上模拟细菌菌落的生长与传播：分支菌落</span>"
    ]
  },
  {
    "objectID": "Demographic noise with two strains.html",
    "href": "Demographic noise with two strains.html",
    "title": "7  该模型模拟了细菌菌落在平坦表面上的生长与扩展过程",
    "section": "",
    "text": "此流程再现了主文本中模拟群体遗传噪声如何导致同样适应度的扩张菌落空间分隔的主要实验方案。\n\nimport cobra\nimport cobra.io # for the ijo1366 model\nimport sys\nimport copy\nimport numpy as np\n#sys.path.append(\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/cometspy\") # not necessary if you pip install cometspy\nimport cometspy as c\n\n我们将使用E. coli core模型\n\necoli = cobra.io.load_model('textbook')\n\n我们现在将把这个模型转换为COMETS模型，并设置两个参数选项：一个是反映群体遗传噪声的参数，被称为“中性漂变”（neutral drift）；另一个是基于对流运动的参数。\n\ngrid_size = 40\necoli_comets = c.model(ecoli)\necoli_comets.reactions.loc[ecoli_comets.reactions.EXCH, \"LB\"] = -1000\necoli_comets.add_nonlinear_diffusion_parameters(convNonlinDiffZero = 0.,\n                                    convNonlinDiffN = 6.e-6,\n                                    convNonlinDiffExponent = 1.0,\n                                    convNonlinDiffHillN = 2.,\n                                    convNonlinDiffHillK = 0.001)\necoli_comets.add_neutral_drift_parameter(0.01)\n\n让我们精确复制 ecoli comets模型。\n\nimport random\n\necoli_comets2 = copy.copy(ecoli_comets)\necoli_comets2.id = \"e_coli_core2\"\n\necoli_comets.initial_pop = [[x, 0, np.random.normal(6.4e-5, 1e-6)] for x in range(grid_size)]\necoli_comets2.initial_pop = [[x, 0, np.random.normal(6.4e-5, 1e-6)] for x in range(grid_size)]\n\n这次模拟将在一个100x100的网格上构建一个位于中心的单一菌落。碳源将在整个区域内均匀分布，并且在网格的一端设定为固定的初始浓度。\n\nly = c.layout([ecoli_comets, ecoli_comets2])\nly.grid = [grid_size, grid_size]\nly.set_specific_metabolite(\"glc__D_e\", 2.2e-3)\nly.set_specific_metabolite(\"h2o_e\", 1000)\nly.set_specific_metabolite(\"nh4_e\", 1000)\nly.set_specific_metabolite(\"o2_e\", 1000)\nly.set_specific_metabolite(\"pi_e\", 1000)\nly.set_specific_metabolite(\"h_e\", 1000)\n\nfor x in range(grid_size):\n    ly.set_specific_static_at_location(\"glc__D_e\", (x, grid_size-1), 1.1e-3)\n\n我们需要设置的主要参数是 biomassmotionstyle，必须设置为“ConvNonlin Diffusion 2D”。然后，为了捕获空间信息，我们还将记录生物量（而不仅仅是总生物量）。最后，我们还将调整一些其他参数。这些存储在字典all_params中。\n\np = c.params()\n\ncycles = 1000\n\np.all_params[\"biomassMotionStyle\"] = \"ConvNonlin Diffusion 2D\"\np.all_params[\"writeBiomassLog\"] = True\np.all_params[\"BiomassLogRate\"] = cycles\np.all_params[\"maxCycles\"] = cycles\np.all_params[\"timeStep\"] = 0.05\np.all_params[\"spaceWidth\"] = 0.01\np.all_params[\"defaultDiffConst\"] = 6.e-6\np.all_params[\"maxSpaceBiomass\"] = 1000000\np.all_params[\"minSpaceBiomass\"] = 1.0e-9\np.all_params[\"allowCellOverlap\"] = True\np.all_params[\"growthDiffRate\"] = 0\np.all_params[\"defaultVmax\"] = 18.5\np.all_params[\"defaultKm\"] = 0.000015\np.all_params[\"defaultHill\"] = 1\np.all_params[\"exchangestyle\"] = \"Monod Style\"\n\n现在我们制作一个模拟对象并运行它。这可能需要一段时间。\n\nsim = c.comets(ly, p)\nsim.run()\n\n现在让我们绘制结果图。我们使用 get_biomass_image 辅助函数，然后使用 matplotlib 进行绘图。\n\nim = sim.get_biomass_image('e_coli_core', cycles).astype(float)\nim = im / np.max(im)\nim2 = sim.get_biomass_image('e_coli_core2',cycles).astype(float)\nim2 = im2 / np.max(im2)\nfinal = np.zeros((grid_size,grid_size,3))\nfinal[:,:,1] = im\nfinal[:,:,2] = im2\nfrom matplotlib import pyplot as plt\nplt.imshow(final)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>该模型模拟了细菌菌落在平坦表面上的生长与扩展过程</span>"
    ]
  },
  {
    "objectID": "Virtual Petri dish.html",
    "href": "Virtual Petri dish.html",
    "title": "8  虚拟培养皿：生长、代谢物和通量的空间模拟和分析",
    "section": "",
    "text": "import cobra\nimport cobra.io # for the e coli core model\nimport sys\nimport numpy as np\n#sys.path.append(\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/cometspy\") # not necessary if you pip install cometspy\nimport cometspy as c\nfrom matplotlib import pyplot as plt\n\n我们将使用大肠杆菌核心模型（ E. coli core），该模型可在cobrapy中获取。\n\ncore = cobra.io.load_model('textbook')\n\n我们将核心（core）模型转化为COMETS模型，打开其下限交换边界（使得边界值由环境决定），并设置对流参数以模拟菌落的推挤扩展过程。同时，我们还会选定若干位置投放起始生物量。\n\necoli = c.model(core)\necoli.open_exchanges()\necoli.add_convection_parameters(packedDensity = 0.022,\n                                    elasticModulus = 1.e-10,\n                                    frictionConstant = 1.0,\n                                    convDiffConstant = 0.0)\necoli.add_noise_variance_parameter(100.)\n\n# ecoli.initial_pop = [[x, x, 1.e-6] for x in [10,20,30,40]]\n\necoli.initial_pop = [[140, 50, 1.e-6],\n                    [58, 162, 1.e-6],\n                    [28,55,1.e-6],\n                    [132, 78, 1.e-6],\n                    [85, 152, 1.e-6],\n                    [73, 123, 1.e-6],\n                    [34, 76, 1.e-6],\n                    [150, 45, 1.e-6],\n                     [120, 73, 1.e-6],\n                     [34, 138, 1.e-6],\n                     [44, 180, 1.e-6],\n                     [180, 150, 1.e-6],\n                     [165, 135, 1.e-6],\n                     [24, 38, 1.e-6],\n                     [44, 45, 1.e-6],\n                     [99, 108, 1.e-6],\n                     [95, 23, 1.e-6],\n                     [35, 101, 1.e-6],\n                     [25, 102, 1.e-6]]\n\n本协议新颖之处在于，“培养皿”被划分为两个不同的空间区域，每个区域具有不同的代谢物扩散系数。用户必须定义一系列参数来实现这一点：首先是“区域映射”，它是一个二维整数矩阵，对应于特定区域；然后是特定于区域的参数。我们将逐一进行这些操作。\n首先，定义区域映射。在这个示例中，我们将使用一个由200x200个小格构成的模拟区域。一半的“培养皿”为一个区域，另一半则为另一个区域。我们将创建一个整数numpy数组来描述这一划分。此外，尽管并非必要，我还会将区域映射绘制成图像进行展示。\n\nwidth = 200\ngrid_size = [width, width] # width boxes in each direction\nregion_map = np.zeros(grid_size, dtype = int) # an integer array filled with zeros\nregion_map[:] = 1 # first fill the whole map with 1s\nregion_map[int(width/2):width,:] = 2 # next fill the bottom half with 2s\n\n# this code here is unnecessary, but useful to visualize your region map:\nplt.imshow(np.transpose(region_map))\n\n区域映射（region_map）看起来是正确的：一个200x200的正方形区域被划分为两个区域。接下来，我们将创建模拟的基础布局，并设置这个区域映射。完成这一步后，我们将设置各区域的具体参数。\n\nly = c.layout([ecoli])\nly.grid = grid_size\nly.set_region_map(region_map)\n\n特定于区域的参数包括每个代谢物在各区域内的扩散系数，以及每个区域中应用于所有代谢物的一个单一摩擦常数。为了简化处理，我们将在每个区域内对所有代谢物使用相同的扩散系数。其中，第一区域的扩散系数为5e-6（平方厘米/秒），第二区域则为5e-7。两个区域的摩擦常数均为1.0。\n因为对每个代谢物我们都采用相同的数值，所以我们只需要创建一个列表，其长度与模拟中代谢物的数量相等。\n\nnum_mets = ly.media.shape[0]\ndiffusion_constant_region1 = [5.e-6] * num_mets\ndiffusion_constant_region2 = [5.e-7] * num_mets\nfriction_constant = 1.0\n\n我们通过指定（整数）区域，然后传递扩散常数和标量摩擦常数的列表来设置这些值。这必须针对每个区域单独执行。\nly.set_region_parameters(1, diffusion_constant_region1, friction_constant) ly.set_region_parameters(2, diffusion_constant_region2, friction_constant)\n培养基浓度最初在“培养皿”中是恒定的。我们将在这里设置这些。\n\nly.set_specific_metabolite(\"glc__D_e\", 5.e-5)\nly.set_specific_metabolite(\"h2o_e\", 1000.)\nly.set_specific_metabolite(\"nh4_e\", 1000.)\nly.set_specific_metabolite(\"h_e\", 1000.)\nly.set_specific_metabolite(\"pi_e\", 1000.)\nly.display_current_media()\n\n接下来，我们设置相关参数。我们必须确保将“biomassMotionStyle”设置为“Convection 2D”，否则生物质将不会使用上面设置的对流参数。\n\np = c.params()\n\np.all_params[\"maxCycles\"] = 5000\np.all_params[\"biomassMotionStyle\"] = \"Convection 2D\"\np.all_params[\"writeBiomassLog\"] = True\np.all_params[\"BiomassLogRate\"] = p.all_params[\"maxCycles\"]\np.all_params[\"defaultKm\"] = 0.01\np.all_params[\"defaultVmax\"] = 10\np.all_params[\"timeStep\"] = 0.01\np.all_params[\"spaceWidth\"] = 0.02\np.all_params[\"maxSpaceBiomass\"] = 10\np.all_params[\"minSpaceBiomass\"] = 1.e-10\np.all_params[\"allowCellOverlap\"] = True\np.all_params[\"writeFluxLog\"] = True\np.all_params[\"FluxLogRate\"] = p.all_params[\"maxCycles\"]\np.all_params[\"writeMediaLog\"] = True\np.all_params[\"MediaLogRate\"] = p.all_params[\"maxCycles\"]\n\n现在我们制作一个模拟对象并运行它。这可能需要一段时间。\n\nsim = c.comets(ly, p)\nsim.run()\n\n接下来，我们依次使用三种不同的辅助函数来获得生物量、代谢物浓度和通量值（生长率，这里），并将它们绘制在二维空间中。\n\nfrom matplotlib import pyplot as plt\nimport matplotlib.colors, matplotlib.cm\nimport copy\nmy_cmap = matplotlib.cm.get_cmap(\"copper\")\nmy_cmap.set_bad((0,0,0))\nim = sim.get_biomass_image('e_coli_core', p.all_params[\"maxCycles\"])\nplt.imshow(im, norm = matplotlib.colors.LogNorm(), cmap = my_cmap)\n\n\n# glucose\nplt.imshow(sim.get_metabolite_image(\"glc__D_e\", p.all_params['maxCycles']+1))\n\n\n# growth rate\nim = sim.get_flux_image(\"e_coli_core\", \"Biomass_Ecoli_core\", p.all_params[\"maxCycles\"])\n\n\nplt.imshow(im)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>虚拟培养皿：生长、代谢物和通量的空间模拟和分析</span>"
    ]
  }
]